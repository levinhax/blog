## 实践背景

项目优化改造

## SSR优势

- 减少首页白屏：服务端直出页面
- SEO：直出的页面包含了页面关键数据信息

现在的 SSR 渲染一般指的都是同构渲染，可以兼顾客户端渲染的大部分优势，所以这里是做改造。

## SSR缺陷

- 服务端压力：
- 开发体验：前端团队可能对服务层代码的把控力

## 方案

![SSR改造方案](./images/001.png)
FCP：首次内容绘制时间，TTI：可交互时间

Vue3 优化的一大原因是尽可能将部分 VDOM 的渲染改为字符串拼接，我们可以按照同样的思路，改造 Vue2。

### 常规优化

**渲染前**
缓存：数据、组件、页面
请求：http、keep-alive
降级：客户端渲染

第一，多级缓存。接口数据、组件和最终吐出的页面均可缓存。这一步的核心是继续把 CPU 压力转移到内存，前者可以缩短请求链路，后两个可以减少渲染计算量。缓存的方式非常灵活，简陋一点就直接用内存缓存，配合 **LRU 算法**基本够用。复杂的场景就需要上 Redis 等内存数据库。

第二，请求复用。我们通常使用封装好的 Request、Axios 等库完成请求，最值得留意的选项就是使用开启了 keep-alive 的 http-agent，它能让后续的请求复用之前建立的连接，减少重复的握手次数。

第三点，降级熔断。如果没有降级，虽然 Node.js 节点比较稳定，不至于因为压力而宕机，但却会出现请求堆积，导致 Node.js 请求后端接口超时，服务将呈现不可用状态。

**渲染后**

- CDN加速静态资源
- 压缩响应体

## 实现

### 继承的概念

所谓继承一般说的是原型继承，一个原型上面定义的方法一般都是基于其实例的用途来定义的。

这里再梳理一下 JS 中继承的几种主要的方式，原型链继承、构造函数继承、组合继承以及原型式继承、寄生式继承、寄生组合式继承和 ES6 的 Class。

想要继承，就必须要提供个父类，提供继承的属性
```
        function Parent(name) {
            this.name = name;
            this.say = function() {
                console.log('name: ', this.name)
            }
        }
        Parent.prototype.age = 10;
```

### 原型链继承

```
        // 原型链继承
        function Child() {
            this.name = 'leon';
        }
        Child.prototype = new Parent(); // 让新实例的原型等于父类的实例
        const child1 = new Child();
        console.log(child1.age); // 10
        child1.say(); // name: leon
        // instanceof 判断元素是否在另一个元素的原型链上
        console.log(child1 instanceof Parent); // true
```

**重点**：

将子构造函数的原型指向父构造函数的实例

**特点**：

1. 实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）

**缺点**：

1. 新实例无法向父类构造函数传参。
2. 继承单一，无法实现多继承，因为原型一次只能被一个实例更改。
3. 所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）

### 构造函数继承

```
        // 构造函数继承
        function Child() {
            Parent.call(this, 'leon'); // 用.call()或.apply()将父类构造函数引入子类函数
            this.age = 12;
        }
        const child1 = new Child();
        console.log(child1.name); // leon
        console.log(child1.age);  // 12
        child1.say(); // name: leon
        console.log(child1 instanceof Parent); // false
```

**重点**：

用.call()或.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））

**特点**：

1. 只继承了父类构造函数的属性，没有继承父类原型的属性。
2. 解决了原型链继承缺点1、2、3。
3. 可以继承多个构造函数属性（call多个）。
4. 创建子类实例时，可以向父类传递参数。

**缺点**：

1. 只能继承父类构造函数的属性和方法，不能继承其原型上的属性和方法。
2. 无法实现构造函数的复用。（每次用每次都要重新调用）
3. 无法实现函数复用，每个新实例都有父类构造函数的副本，臃肿

### 组合继承

（组合原型链继承和借用构造函数继承）（常用）

```
        // 组合继承
        function Child(name) {
            Parent.call(this, name); // 借用构造函数模式，第一次调用父类构造器，子类实例增加父类实例
        }
        Child.prototype = new Parent(); // 原型链继承，经过new运算符，第二次调用父类构造器，子类原型也增加了父类实例
        const child1 = new Child('leon');
        console.log(child1.name); // leon
        console.log(child1.age);  // 10
        child1.say(); // name: leon
        console.log(child1 instanceof Parent); // true
```

**重点**：

结合了两种模式(原型链继承、构造函数继承)的优点，传参和复用

**特点**：

1. 可以继承父类原型上的属性，可以传参，可复用。
2. 每个新实例引入的构造函数属性是私有的。

**缺点**：

调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。

### 原型式继承

```
        // 原型式继承，先封装一个函数，用来输出对象和承载继承的原型
        function content(obj) {
            function F() {}
            F.prototype = obj; // 继承了传入的参数
            return new F(); // 返回函数对象
        }
        const parent1 = new Parent('leon'); // 拿到父类的实例
        const child1 = content(parent1);
        console.log(child1.name); // leon
        console.log(child1.age);  // 10
        child1.say(); // name: leon
        console.log(child1 instanceof Parent); // true
```

**重点**：

用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。

**特点**：

类似于复制一个对象，用函数来包装。

**缺点**：

1. 所有实例都会继承原型上的属性。
2. 无法实现复用。（新实例属性都是后面添加的）

### 寄生式继承

```
        // 寄生式继承
        function content(obj) {
            function F() {}
            F.prototype = obj; // 继承了传入的参数
            return new F(); // 返回函数对象
        }
        const parent1 = new Parent(); // 拿到父类的实例
        // 以上是原型式继承，给原型式继承再套个壳子传递参数
        function subObject(obj) {
            let child = content(obj);
            child.name = 'leon';
            return child;
        }
        const child1 = subObject(parent1);
        // 这个函数声明之后就变成了可增添属性的对象
        console.log(typeof subObject);  // function
        console.log(typeof child1); // object
        console.log(child1.name); // leon
```

**重点**：

就是给原型式继承外面套了个壳子。

**优点**：

没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。

**缺点**：没用到原型，无法复用。

### 寄生组合式继承（常用）

寄生：在函数内返回对象然后调用
组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参

```
        // 寄生组合式继承
        // 寄生
        function content(obj) {
            function F() {}
            F.prototype = obj;
            return new F();
        }
        const child = content(Parent.prototype);
        // 组合
        function Sub() {
            Parent.call(this); //继承了父类构造函数的属性
        }
        // 解决了组合式两次调用构造函数属性的缺点
        Sub.prototype = child;
        child.constructor = Sub;
        const sub1 = new Sub();
        console.log(sub1.age); // 10
```

### ES6 class

```
class Parent {
    constructor(name, friends) { // 该属性在构造函数上，不共享
        this.name = name
        this.friends = friends
    }
    log() { // 该方法在原型上，共享
        return this
    }
}
Parent.prototype.share = [1, 2, 3] // 原型上的属性，共享

class Child extends Parent {
    constructor(name, friends, gender) {
        super(name, friends)
        this.gender = gender
    }
}
```

参考:

- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
- https://juejin.im/post/5eb250f3f265da7bf6742594#heading-3
